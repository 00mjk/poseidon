<!DOCTYPE html>
<html lang="en">
<head>
    <title>Poseidon Documentation</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="favicon.ico">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- FontAwesome JS -->
    <script defer src="https://use.fontawesome.com/releases/v5.1.1/js/all.js" integrity="sha384-BtvRZcyfv4r0x/phJt9Y9HhnN5ur1Z+kZbKVgzVBAlQZX4jvAuImlIz+bG7TS00a" crossorigin="anonymous"></script>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/lightbox/dist/ekko-lightbox.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">

</head>

<body class="body-blue">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                        <a href="index.html">
                            <span aria-hidden="true" class="icon_documents_alt icon"></span>
                            <span class="text-highlight">Poseidon</span><span class="text-bold">Docs</span>
                        </a>
                    </h1>
                </div><!--//branding-->
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="index.html">Home</a></li>
                    <li class="breadcrumb-item active">Tasks</li>
                </ol>
            </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div id="doc-header" class="doc-header text-center">
                    <h1 class="doc-title"><span aria-hidden="true" class="icon icon_pencil-edit"></span> Tasks</h1>
                    <div class="meta"><i class="far fa-clock"></i> Last updated: August 22th, 2018</div>
                </div><!--//doc-header-->
                <div class="doc-body row">
                    <div class="doc-content col-md-9 col-12 order-1">
                        <div class="content-inner">
                            <section id="logs" class="doc-section">
                                <h2 class="section-title">Get Logs</h2>
                                <div class="section-block">
                                    <p>Getting the Poseidon logs is straightforward.  The logs for Poseidon are split into two different logs, one that goes into the system log for status and health of Poseidon and one that is informational about what Poseidon is doing.
                                    </p>
                                    <p>To get the Poseidon system logs, you can use journalctl if you prefer, like so:
                                    <pre><code class="language-git">journalctl -u poseidon</code></pre>
                                    Alternatively, if you aren't familiar with journalctl or want to use that, you can simply use:
                                    <pre><code class="language-git">poseidon system-logs</code></pre>
                                    Either will get you the same logs using journalctl behind the scenes. Note this command will also follow the log file in case any new records come in, to exit out of the command when you're done, use <code>ctrl-c</code>.
                                    </p>
                                    <p>Getting the informational logs is similar, except they are written out to the log file: <code>/var/log/poseidon.log</code> so instead of using journalctl, you can use something like:
                                    <pre><code class="language-git">cat /var/log/poseidon.log</code></pre>
                                    Similarly to the system logs, there is a Poseidon command that will get these logs and follow them:
                                    <pre><code class="language-git">poseidon logs</code></pre>
                                    The system logs will have any errors or warnings associated with Poseidon, as well as if it was started or stopped, and if Poseidon is generally in a healthy state.  The informational logs will have runtime information such as learned devices, classifications, and any additional metadata discovered about endpoints. The informational logs will also be where any debugging logging will go.
                                    </p>
                                </div><!--//section-block-->
                            </section><!--//doc-section-->
                            <section id="endpoint-state" class="doc-section">
                                <h2 class="section-title">Get State of Endpoints</h2>
                                <div class="section-block">
                                    <p>Poseidon has an API which will let you query about the network that Poseidon has learned. To get the URL of the API do the following:
                                    <pre><code class="language-git">poseidon api
Poseidon API is accessible here: http://192.168.0.8:32771/v1</code></pre>
                                    The returned URL will provide you all of the available API paths:
                                    <pre><code class="language-git">["/v1", "/v1/info", "/v1/network", "/v1/network_full"]</code></pre>
                                    To get the full state of the network endpoints that Poseidon knows about for instance, you'd browse to: <code>http://192.168.0.8:32771/v1/network_full</code> and it would return something like the following:
                                    <pre><code class="language-git">{
  "dataset": [
    {
      "ip": "fe80::200:ff:fe00:2",
      "mac": "00:00:00:00:00:02",
      "segment": "switch-1",
      "port": "2",
      "tenant": "VLAN8",
      "record_source": "Poseidon",
      "role": "Unknown",
      "os": "Unknown",
      "behavior": 0,
      "hash": "67abf9ebc159477cc0ae56cf364d6806ac37ca1a",
      "state": "MIRRORING",
      "active": 1
    },
    {
      "ip": "fe80::200:ff:fe00:1",
      "mac": "00:00:00:00:00:01",
      "segment": "switch-1",
      "port": "1",
      "tenant": "VLAN8",
      "record_source": "Poseidon",
      "role": "Unknown",
      "os": "Unknown",
      "behavior": 0,
      "hash": "06993213bb893220bdc674c4b8efd9afd17b9870",
      "state": "MIRRORING",
      "active": 1
    },
    {
      "ip": "None",
      "mac": "00:00:00:00:00:02",
      "segment": "switch-1",
      "port": "2",
      "tenant": "VLAN8",
      "record_source": "Poseidon",
      "role": "Unknown",
      "os": "Unknown",
      "behavior": 0,
      "hash": "67abf9ebc159477cc0ae56cf364d6806ac37ca1a",
      "state": "MIRRORING",
      "active": 1
    }
  ]
}</code></pre>
                                    </p>
                                </div><!--//section-block-->
                            </section><!--//doc-section-->
                            <section id="submit-pcap" class="doc-section">
                                <h2 class="section-title">Submit PCAP Files for Analysis</h2>
                                <div class="section-block">
                                    <p>Behind the scenes Poseidon uses the Vent pipeline to orchestrate collection and analysis. By default Poseidon connects to an SDN controller and uses events from that to tell Vent what to collect. However, it's possible to use the same analysis pipeline and skip over the SDN controller and collection pieces. Suppose instead you already have a PCAP you've collected and you want to know what devices are in that capture and what they are. You can simply drop that PCAP file into the pipeline and Vent will take care of the rest. Vent is looking for PCAP files from Poseidon in <code>/opt/vent_files</code>, so by putting your file there (recommend a <code>mv</code> operation that is atomic) it will then trigger the rest of the downstream pipeline which includes device classification.
                                    </p>
                                    <p>The major difference will be in finding the results. Since this analysis wasn't triggered by a new device showing up on the network from an SDN controller, Poseidon doesn't have an ID to keep track of any endpoints that are in these one-off captures and so it doesn't know what to do with them. Instead these results get logged in the Vent system. See the <a href="#get-vent-logs">Get Vent Logs</a> section on how to navigate those to get the results.
                                    </p>
                                </div><!--//section-block-->
                            </section><!--//doc-section-->
                            <section id="trigger-learn" class="doc-section">
                                <h2 class="section-title">Trigger Device Learning</h2>
                                <div class="section-block">
                                    <p>Either BCF or Faucet will now learn devices at Layer 2, meaning once a device appears on the network with a MAC address generating traffic, it will get sent to Poseidon as a device to learn. For Poseidon to properly learn about this device and make a classification and fingerprint it needs that device to generate TCP and/or UDP traffic with at least 5 sessions during the mirroring stage.  An unknown device gets putting to investigation which will start a network capture that mirrors the traffic of the device.  The default time of this capture is 15 minutes, and starts when the device is first seen and passed on from the controller to Poseidon.  Poseidon has a default setting of concurrently learning about 2 devices for investigation, so if more than that are appearing at the same time, they will get queued up until the current running investigations finish their 15 minute intervals.  Poseidon will also reinvestigate already known devices once it is idle and no longer learning unknown devices.
                                    </p>
                                    <p>The simplest way see the above explained behavior is to plug a new device into the switch controlled by your SDN controller, and then once you see that Poseidon has put your new device into a mirroring state (using <code>poseidon logs</code>) make sure to initiate traffic that will create at least 5 sessions of TCP or UDP traffic on that device.  Once the 15 minutes of capture is complete, it will send that traffic off to the machine learning portion of Poseidon as well as p0f to <a href="examples.html#classification">get a classification of the device role</a> and a fingerprint of the device type.
                                    </p>
                                </div><!--//section-block-->
                            </section><!--//doc-section-->
                            <section id="get-vent-logs" class="doc-section">
                                <h2 class="section-title">Get Vent Logs</h2>
                                <div class="section-block">
                                    <p>Vent is the orchestration that ties together the various pieces of Poseidon, as well as making it flexible to include or exclude additional <a href="concepts.html#vent-plugins-arch">plugins</a>. To follow the logs of the different plugins that are installed once Vent is running (Poseidon will start Vent for you) simplyi (<code>ctrl-c</code> to exit):
                                    <pre><code class="language-git">docker logs -f cyberreboot-vent-syslog-master</code></pre>
                                    You can verify that Vent is running by using <code>docker ps</code> and depending on what plugins you have enabled should see a number of Vent containers. There is the main one that controls all the others called <code>vent</code> and minimally the syslog one which will have all the logs called <code>cyberreboot-vent-syslog-master</code>.
                                    </p>
                                    <p>The main Vent container also has its own logs that can be used to verify that the system itself is healthy (in case, for example, the syslog container fails to start). To get those logs, you'll need to exec into the vent container and cat out the log:
                                    <pre><code class="language-git">docker exec -it vent /bin/sh
/ # cd /root/.vent
~/.vent # cat vent.log
~/.vent # exit</code></pre>
                                    </p>
                                </div><!--//section-block-->
                            </section><!--//doc-section-->
                        </div><!--//content-inner-->
                    </div><!--//doc-content-->
                    <div class="doc-sidebar col-md-3 col-12 order-0 d-none d-md-flex">
                        <div id="doc-nav" class="doc-nav">
                            <nav id="doc-menu" class="nav doc-menu flex-column sticky">
                                <a class="nav-link scrollto" href="#logs">Get Logs</a>
                                <a class="nav-link scrollto" href="#endpoint-state">Get State of Endpoints</a>
                                <a class="nav-link scrollto" href="#submit-pcap">Submit PCAP Files for Analysis</a>
                                <a class="nav-link scrollto" href="#trigger-learn">Trigger Device Learning</a>
                                <a class="nav-link scrollto" href="#get-vent-logs">Get Vent Logs</a>
                            </nav><!--//doc-menu-->
                        </div>
                    </div><!--//doc-sidebar-->
                </div><!--//doc-body-->
            </div><!--//container-->
        </div><!--//doc-wrapper-->
    </div><!--//page-wrapper-->

    <footer id="footer" class="footer text-center">
        <div class="container">
            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can buy the commercial license via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Written by the <a href="https://github.com/cyberreboot">Cyber Reboot team</a> and designed with <i class="fas fa-heart"></i> by <a href="https://themes.3rdwavemedia.com/" target="_blank">Xiaoying Riley</a>.</small>
        </div><!--//container-->
    </footer><!--//footer-->

    <!-- Main Javascript -->
    <script type="text/javascript" src="assets/plugins/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>
    <script type="text/javascript" src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"></script>
    <script type="text/javascript" src="assets/plugins/stickyfill/dist/stickyfill.min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>

</body>
</html>
